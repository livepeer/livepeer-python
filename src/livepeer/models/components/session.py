"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from .ffmpeg_profile import FfmpegProfile
from .recordingspec import RecordingSpec
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from livepeer import utils
from typing import List, Optional


class RecordingStatus(str, Enum):
    r"""The status of the recording process of this stream session."""
    WAITING = 'waiting'
    READY = 'ready'
    FAILED = 'failed'
    NONE = 'none'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Session:
    UNSET='__SPEAKEASY_UNSET__'
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    kind: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kind'), 'exclude': lambda f: f is None }})
    r"""Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible."""
    user_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('userId'), 'exclude': lambda f: f is None }})
    r"""Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible."""
    last_seen: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastSeen'), 'exclude': lambda f: f is None }})
    source_segments: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sourceSegments'), 'exclude': lambda f: f is None }})
    transcoded_segments: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transcodedSegments'), 'exclude': lambda f: f is None }})
    source_segments_duration: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sourceSegmentsDuration'), 'exclude': lambda f: f is None }})
    r"""Duration of all the source segments, sec"""
    transcoded_segments_duration: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transcodedSegmentsDuration'), 'exclude': lambda f: f is None }})
    r"""Duration of all the transcoded segments, sec"""
    source_bytes: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sourceBytes'), 'exclude': lambda f: f is None }})
    transcoded_bytes: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transcodedBytes'), 'exclude': lambda f: f is None }})
    ingest_rate: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ingestRate'), 'exclude': lambda f: f is None }})
    r"""Rate at which sourceBytes increases (bytes/second)"""
    outgoing_rate: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('outgoingRate'), 'exclude': lambda f: f is None }})
    r"""Rate at which transcodedBytes increases (bytes/second)"""
    is_healthy: Optional[bool] = dataclasses.field(default=UNSET, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isHealthy'), 'exclude': lambda f: f is Session.UNSET }})
    r"""Indicates whether the stream is healthy or not."""
    issues: Optional[List[str]] = dataclasses.field(default=UNSET, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('issues'), 'exclude': lambda f: f is Session.UNSET }})
    r"""A string array of human-readable errors describing issues affecting the stream, if any."""
    created_at: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdAt'), 'exclude': lambda f: f is None }})
    r"""Timestamp (in milliseconds) at which stream object was created"""
    parent_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('parentId'), 'exclude': lambda f: f is None }})
    r"""Points to parent stream object"""
    project_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('projectId'), 'exclude': lambda f: f is None }})
    r"""The ID of the project"""
    record: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('record'), 'exclude': lambda f: f is None }})
    r"""Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store."""
    recording_status: Optional[RecordingStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recordingStatus'), 'exclude': lambda f: f is None }})
    r"""The status of the recording process of this stream session."""
    recording_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recordingUrl'), 'exclude': lambda f: f is None }})
    r"""URL for accessing the recording of this stream session."""
    mp4_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('mp4Url'), 'exclude': lambda f: f is None }})
    r"""The URL for the stream session recording packaged in an MP4."""
    playback_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('playbackId'), 'exclude': lambda f: f is None }})
    r"""The playback ID to use with the Playback Info endpoint to retrieve playback URLs."""
    profiles: Optional[List[FfmpegProfile]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('profiles'), 'exclude': lambda f: f is None }})
    recording_spec: Optional[RecordingSpec] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recordingSpec'), 'exclude': lambda f: f is None }})
    r"""Configuration for recording the stream. This can only be set if
    `record` is true.
    """
    

