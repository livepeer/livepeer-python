"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .ffmpeg_profile import FfmpegProfile, FfmpegProfileTypedDict
from .recordingspec import RecordingSpec, RecordingSpecTypedDict
from enum import Enum
from livepeer.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional, TypedDict
from typing_extensions import Annotated, NotRequired


class RecordingStatus(str, Enum):
    r"""The status of the recording process of this stream session."""

    WAITING = "waiting"
    READY = "ready"
    FAILED = "failed"
    DELETED = "deleted"
    NONE = "none"


class SessionTypedDict(TypedDict):
    name: str
    id: NotRequired[str]
    kind: NotRequired[str]
    user_id: NotRequired[str]
    last_seen: NotRequired[float]
    source_segments: NotRequired[float]
    transcoded_segments: NotRequired[float]
    source_segments_duration: NotRequired[float]
    r"""Duration of all the source segments, sec"""
    transcoded_segments_duration: NotRequired[float]
    r"""Duration of all the transcoded segments, sec"""
    source_bytes: NotRequired[float]
    transcoded_bytes: NotRequired[float]
    ingest_rate: NotRequired[float]
    r"""Rate at which sourceBytes increases (bytes/second)"""
    outgoing_rate: NotRequired[float]
    r"""Rate at which transcodedBytes increases (bytes/second)"""
    is_healthy: NotRequired[Nullable[bool]]
    r"""Indicates whether the stream is healthy or not."""
    issues: NotRequired[Nullable[List[str]]]
    r"""A string array of human-readable errors describing issues affecting the stream, if any."""
    created_at: NotRequired[float]
    r"""Timestamp (in milliseconds) at which stream object was created"""
    parent_id: NotRequired[str]
    r"""Points to parent stream object"""
    project_id: NotRequired[str]
    r"""The ID of the project"""
    record: NotRequired[bool]
    r"""Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.

    """
    recording_status: NotRequired[RecordingStatus]
    r"""The status of the recording process of this stream session."""
    recording_url: NotRequired[str]
    r"""URL for accessing the recording of this stream session."""
    mp4_url: NotRequired[str]
    r"""The URL for the stream session recording packaged in an MP4."""
    playback_id: NotRequired[str]
    r"""The playback ID to use with the Playback Info endpoint to retrieve playback URLs."""
    profiles: NotRequired[List[FfmpegProfileTypedDict]]
    r"""Profiles to transcode the stream into. If not specified, a default
    set of profiles will be used with 240p, 360p, 480p and 720p
    resolutions. Keep in mind that the source rendition is always kept.

    """
    recording_spec: NotRequired[RecordingSpecTypedDict]
    r"""Configuration for recording the stream. This can only be set if
    `record` is true.

    """


class Session(BaseModel):
    name: str

    id: Optional[str] = None

    kind: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None

    user_id: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible.",
            alias="userId",
        ),
    ] = None

    last_seen: Annotated[Optional[float], pydantic.Field(alias="lastSeen")] = None

    source_segments: Annotated[
        Optional[float], pydantic.Field(alias="sourceSegments")
    ] = None

    transcoded_segments: Annotated[
        Optional[float], pydantic.Field(alias="transcodedSegments")
    ] = None

    source_segments_duration: Annotated[
        Optional[float], pydantic.Field(alias="sourceSegmentsDuration")
    ] = None
    r"""Duration of all the source segments, sec"""

    transcoded_segments_duration: Annotated[
        Optional[float], pydantic.Field(alias="transcodedSegmentsDuration")
    ] = None
    r"""Duration of all the transcoded segments, sec"""

    source_bytes: Annotated[Optional[float], pydantic.Field(alias="sourceBytes")] = None

    transcoded_bytes: Annotated[
        Optional[float], pydantic.Field(alias="transcodedBytes")
    ] = None

    ingest_rate: Annotated[Optional[float], pydantic.Field(alias="ingestRate")] = None
    r"""Rate at which sourceBytes increases (bytes/second)"""

    outgoing_rate: Annotated[Optional[float], pydantic.Field(alias="outgoingRate")] = (
        None
    )
    r"""Rate at which transcodedBytes increases (bytes/second)"""

    is_healthy: Annotated[OptionalNullable[bool], pydantic.Field(alias="isHealthy")] = (
        UNSET
    )
    r"""Indicates whether the stream is healthy or not."""

    issues: OptionalNullable[List[str]] = UNSET
    r"""A string array of human-readable errors describing issues affecting the stream, if any."""

    created_at: Annotated[Optional[float], pydantic.Field(alias="createdAt")] = None
    r"""Timestamp (in milliseconds) at which stream object was created"""

    parent_id: Annotated[Optional[str], pydantic.Field(alias="parentId")] = None
    r"""Points to parent stream object"""

    project_id: Annotated[Optional[str], pydantic.Field(alias="projectId")] = None
    r"""The ID of the project"""

    record: Optional[bool] = None
    r"""Whether the stream should be recorded. Uses default settings. For more customization, create and configure an object store.

    """

    recording_status: Annotated[
        Optional[RecordingStatus], pydantic.Field(alias="recordingStatus")
    ] = None
    r"""The status of the recording process of this stream session."""

    recording_url: Annotated[Optional[str], pydantic.Field(alias="recordingUrl")] = None
    r"""URL for accessing the recording of this stream session."""

    mp4_url: Annotated[Optional[str], pydantic.Field(alias="mp4Url")] = None
    r"""The URL for the stream session recording packaged in an MP4."""

    playback_id: Annotated[Optional[str], pydantic.Field(alias="playbackId")] = None
    r"""The playback ID to use with the Playback Info endpoint to retrieve playback URLs."""

    profiles: Optional[List[FfmpegProfile]] = None
    r"""Profiles to transcode the stream into. If not specified, a default
    set of profiles will be used with 240p, 360p, 480p and 720p
    resolutions. Keep in mind that the source rendition is always kept.

    """

    recording_spec: Annotated[
        Optional[RecordingSpec], pydantic.Field(alias="recordingSpec")
    ] = None
    r"""Configuration for recording the stream. This can only be set if
    `record` is true.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "id",
            "kind",
            "userId",
            "lastSeen",
            "sourceSegments",
            "transcodedSegments",
            "sourceSegmentsDuration",
            "transcodedSegmentsDuration",
            "sourceBytes",
            "transcodedBytes",
            "ingestRate",
            "outgoingRate",
            "isHealthy",
            "issues",
            "createdAt",
            "parentId",
            "projectId",
            "record",
            "recordingStatus",
            "recordingUrl",
            "mp4Url",
            "playbackId",
            "profiles",
            "recordingSpec",
        ]
        nullable_fields = ["isHealthy", "issues"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
