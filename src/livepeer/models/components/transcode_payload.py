"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .input_creator_id import InputCreatorID, InputCreatorIDTypedDict
from .transcode_profile import TranscodeProfile, TranscodeProfileTypedDict
from enum import Enum
from livepeer.types import BaseModel
import pydantic
from typing import List, Optional, TypedDict, Union
from typing_extensions import Annotated, NotRequired


class InputType(str, Enum):
    r"""Type of service. This is optional and defaults to `url` if
    ŚURL field is provided.

    """

    S3 = "s3"


class CredentialsTypedDict(TypedDict):
    r"""Credentials for the private input video storage"""

    access_key_id: str
    r"""Access Key ID"""
    secret_access_key: str
    r"""Secret Access Key"""


class Credentials(BaseModel):
    r"""Credentials for the private input video storage"""

    access_key_id: Annotated[str, pydantic.Field(alias="accessKeyId")]
    r"""Access Key ID"""

    secret_access_key: Annotated[str, pydantic.Field(alias="secretAccessKey")]
    r"""Secret Access Key"""


class Input2TypedDict(TypedDict):
    r"""S3-like storage input video"""

    type: InputType
    r"""Type of service. This is optional and defaults to `url` if
    ŚURL field is provided.

    """
    endpoint: str
    r"""Service endpoint URL (AWS S3 endpoint list: https://docs.aws.amazon.com/general/latest/gr/s3.html, GCP S3 endpoint: https://storage.googleapis.com, Storj: https://gateway.storjshare.io)"""
    bucket: str
    r"""Bucket with input file"""
    path: str
    r"""Path to the input file inside the bucket"""
    credentials: CredentialsTypedDict
    r"""Credentials for the private input video storage"""


class Input2(BaseModel):
    r"""S3-like storage input video"""

    type: InputType
    r"""Type of service. This is optional and defaults to `url` if
    ŚURL field is provided.

    """

    endpoint: str
    r"""Service endpoint URL (AWS S3 endpoint list: https://docs.aws.amazon.com/general/latest/gr/s3.html, GCP S3 endpoint: https://storage.googleapis.com, Storj: https://gateway.storjshare.io)"""

    bucket: str
    r"""Bucket with input file"""

    path: str
    r"""Path to the input file inside the bucket"""

    credentials: Credentials
    r"""Credentials for the private input video storage"""


class Input1TypedDict(TypedDict):
    r"""URL input video"""

    url: str
    r"""URL of the video to transcode"""


class Input1(BaseModel):
    r"""URL input video"""

    url: str
    r"""URL of the video to transcode"""


InputTypedDict = Union[Input1TypedDict, Input2TypedDict]


Input = Union[Input1, Input2]


class TranscodePayloadStorageType(str, Enum):
    r"""Type of service used for output files"""

    WEB3_STORAGE = "web3.storage"


class TranscodePayloadStorageCredentialsTypedDict(TypedDict):
    r"""Delegation proof for Livepeer to be able to upload to
    web3.storage

    """

    proof: str
    r"""Base64 encoded UCAN delegation proof"""


class TranscodePayloadStorageCredentials(BaseModel):
    r"""Delegation proof for Livepeer to be able to upload to
    web3.storage

    """

    proof: str
    r"""Base64 encoded UCAN delegation proof"""


class Storage2TypedDict(TypedDict):
    r"""Storage for the output files"""

    type: TranscodePayloadStorageType
    r"""Type of service used for output files"""
    credentials: TranscodePayloadStorageCredentialsTypedDict
    r"""Delegation proof for Livepeer to be able to upload to
    web3.storage

    """


class Storage2(BaseModel):
    r"""Storage for the output files"""

    type: TranscodePayloadStorageType
    r"""Type of service used for output files"""

    credentials: TranscodePayloadStorageCredentials
    r"""Delegation proof for Livepeer to be able to upload to
    web3.storage

    """


class StorageType(str, Enum):
    r"""Type of service used for output files"""

    S3 = "s3"


class StorageCredentialsTypedDict(TypedDict):
    r"""Credentials for the output video storage"""

    access_key_id: str
    r"""Access Key ID"""
    secret_access_key: str
    r"""Secret Access Key"""


class StorageCredentials(BaseModel):
    r"""Credentials for the output video storage"""

    access_key_id: Annotated[str, pydantic.Field(alias="accessKeyId")]
    r"""Access Key ID"""

    secret_access_key: Annotated[str, pydantic.Field(alias="secretAccessKey")]
    r"""Secret Access Key"""


class Storage1TypedDict(TypedDict):
    r"""Storage for the output files"""

    type: StorageType
    r"""Type of service used for output files"""
    endpoint: str
    r"""Service endpoint URL (AWS S3 endpoint list: https://docs.aws.amazon.com/general/latest/gr/s3.html, GCP S3 endpoint: https://storage.googleapis.com, Storj: https://gateway.storjshare.io)"""
    bucket: str
    r"""Bucket with output files"""
    credentials: StorageCredentialsTypedDict
    r"""Credentials for the output video storage"""


class Storage1(BaseModel):
    r"""Storage for the output files"""

    type: StorageType
    r"""Type of service used for output files"""

    endpoint: str
    r"""Service endpoint URL (AWS S3 endpoint list: https://docs.aws.amazon.com/general/latest/gr/s3.html, GCP S3 endpoint: https://storage.googleapis.com, Storj: https://gateway.storjshare.io)"""

    bucket: str
    r"""Bucket with output files"""

    credentials: StorageCredentials
    r"""Credentials for the output video storage"""


TranscodePayloadStorageTypedDict = Union[Storage2TypedDict, Storage1TypedDict]


TranscodePayloadStorage = Union[Storage2, Storage1]


class HlsTypedDict(TypedDict):
    r"""HLS output format"""

    path: str
    r"""Path for the HLS output"""


class Hls(BaseModel):
    r"""HLS output format"""

    path: str
    r"""Path for the HLS output"""


class Mp4TypedDict(TypedDict):
    r"""MP4 output format"""

    path: str
    r"""Path for the MP4 output"""


class Mp4(BaseModel):
    r"""MP4 output format"""

    path: str
    r"""Path for the MP4 output"""


class Fmp4TypedDict(TypedDict):
    r"""FMP4 output format"""

    path: str
    r"""Path for the FMP4 output"""


class Fmp4(BaseModel):
    r"""FMP4 output format"""

    path: str
    r"""Path for the FMP4 output"""


class OutputsTypedDict(TypedDict):
    r"""Output formats"""

    hls: NotRequired[HlsTypedDict]
    r"""HLS output format"""
    mp4: NotRequired[Mp4TypedDict]
    r"""MP4 output format"""
    fmp4: NotRequired[Fmp4TypedDict]
    r"""FMP4 output format"""


class Outputs(BaseModel):
    r"""Output formats"""

    hls: Optional[Hls] = None
    r"""HLS output format"""

    mp4: Optional[Mp4] = None
    r"""MP4 output format"""

    fmp4: Optional[Fmp4] = None
    r"""FMP4 output format"""


class TranscodePayloadTypedDict(TypedDict):
    input: InputTypedDict
    storage: TranscodePayloadStorageTypedDict
    outputs: OutputsTypedDict
    r"""Output formats"""
    profiles: NotRequired[List[TranscodeProfileTypedDict]]
    target_segment_size_secs: NotRequired[float]
    r"""How many seconds the duration of each output segment should be"""
    creator_id: NotRequired[InputCreatorIDTypedDict]
    c2pa: NotRequired[bool]
    r"""Decides if the output video should include C2PA signature"""


class TranscodePayload(BaseModel):
    input: Input

    storage: TranscodePayloadStorage

    outputs: Outputs
    r"""Output formats"""

    profiles: Optional[List[TranscodeProfile]] = None

    target_segment_size_secs: Annotated[
        Optional[float], pydantic.Field(alias="targetSegmentSizeSecs")
    ] = None
    r"""How many seconds the duration of each output segment should be"""

    creator_id: Annotated[
        Optional[InputCreatorID], pydantic.Field(alias="creatorId")
    ] = None

    c2pa: Optional[bool] = None
    r"""Decides if the output video should include C2PA signature"""
