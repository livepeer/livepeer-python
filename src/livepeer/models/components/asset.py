"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .creator_id import CreatorID, CreatorIDTypedDict
from .encryption_output import EncryptionOutput, EncryptionOutputTypedDict
from .ipfs_file_info import IpfsFileInfo, IpfsFileInfoTypedDict
from .playback_policy import PlaybackPolicy, PlaybackPolicyTypedDict
from .storage_status import StorageStatus, StorageStatusTypedDict
from .transcode_profile import TranscodeProfile, TranscodeProfileTypedDict
from enum import Enum
from livepeer.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Any, List, Optional, TypedDict, Union
from typing_extensions import Annotated, NotRequired


class AssetType(str, Enum):
    r"""Type of the asset."""

    VIDEO = "video"
    AUDIO = "audio"


class AssetSource3Type(str, Enum):
    DIRECT_UPLOAD = "directUpload"
    CLIP = "clip"


class Source3TypedDict(TypedDict):
    type: AssetSource3Type
    encryption: NotRequired[EncryptionOutputTypedDict]
    source_id: NotRequired[str]
    r"""ID of the asset or stream from which this asset was created."""
    session_id: NotRequired[str]
    r"""ID of the session from which this asset was created."""
    playback_id: NotRequired[str]
    r"""Playback ID of the asset or stream from which this asset was created."""
    requester_id: NotRequired[str]
    r"""ID of the requester from which this asset was created."""
    asset_id: NotRequired[str]
    r"""ID of the asset from which this asset was created."""


class Source3(BaseModel):
    type: AssetSource3Type

    encryption: Optional[EncryptionOutput] = None

    source_id: Annotated[Optional[str], pydantic.Field(alias="sourceId")] = None
    r"""ID of the asset or stream from which this asset was created."""

    session_id: Annotated[Optional[str], pydantic.Field(alias="sessionId")] = None
    r"""ID of the session from which this asset was created."""

    playback_id: Annotated[Optional[str], pydantic.Field(alias="playbackId")] = None
    r"""Playback ID of the asset or stream from which this asset was created."""

    requester_id: Annotated[Optional[str], pydantic.Field(alias="requesterId")] = None
    r"""ID of the requester from which this asset was created."""

    asset_id: Annotated[Optional[str], pydantic.Field(alias="assetId")] = None
    r"""ID of the asset from which this asset was created."""


class AssetSourceType(str, Enum):
    RECORDING = "recording"


class TwoTypedDict(TypedDict):
    type: AssetSourceType
    session_id: str
    r"""ID of the session from which this asset was created"""


class Two(BaseModel):
    type: AssetSourceType

    session_id: Annotated[str, pydantic.Field(alias="sessionId")]
    r"""ID of the session from which this asset was created"""


class SourceType(str, Enum):
    URL = "url"


class Source1TypedDict(TypedDict):
    type: SourceType
    url: str
    r"""URL from which the asset was uploaded."""
    gateway_url: NotRequired[str]
    r"""Gateway URL from asset if parsed from provided URL on upload."""
    encryption: NotRequired[EncryptionOutputTypedDict]


class Source1(BaseModel):
    type: SourceType

    url: str
    r"""URL from which the asset was uploaded."""

    gateway_url: Annotated[Optional[str], pydantic.Field(alias="gatewayUrl")] = None
    r"""Gateway URL from asset if parsed from provided URL on upload."""

    encryption: Optional[EncryptionOutput] = None


SourceTypedDict = Union[TwoTypedDict, Source1TypedDict, Source3TypedDict]


Source = Union[Two, Source1, Source3]


class AssetNftMetadataTemplate(str, Enum):
    r"""Name of the NFT metadata template to export. 'player'
    will embed the Livepeer Player on the NFT while 'file'
    will reference only the immutable MP4 files.

    """

    FILE = "file"
    PLAYER = "player"


class AssetNftMetadataTypedDict(TypedDict):
    r"""Additional data to add to the NFT metadata exported to
    IPFS. Will be deep merged with the default metadata
    exported.

    """


class AssetNftMetadata(BaseModel):
    r"""Additional data to add to the NFT metadata exported to
    IPFS. Will be deep merged with the default metadata
    exported.

    """


class AssetSpecTypedDict(TypedDict):
    nft_metadata_template: NotRequired[AssetNftMetadataTemplate]
    r"""Name of the NFT metadata template to export. 'player'
    will embed the Livepeer Player on the NFT while 'file'
    will reference only the immutable MP4 files.

    """
    nft_metadata: NotRequired[AssetNftMetadataTypedDict]
    r"""Additional data to add to the NFT metadata exported to
    IPFS. Will be deep merged with the default metadata
    exported.

    """


class AssetSpec(BaseModel):
    nft_metadata_template: Annotated[
        Optional[AssetNftMetadataTemplate], pydantic.Field(alias="nftMetadataTemplate")
    ] = AssetNftMetadataTemplate.FILE
    r"""Name of the NFT metadata template to export. 'player'
    will embed the Livepeer Player on the NFT while 'file'
    will reference only the immutable MP4 files.

    """

    nft_metadata: Annotated[
        Optional[AssetNftMetadata], pydantic.Field(alias="nftMetadata")
    ] = None
    r"""Additional data to add to the NFT metadata exported to
    IPFS. Will be deep merged with the default metadata
    exported.

    """


class AssetIpfsTypedDict(TypedDict):
    spec: NotRequired[AssetSpecTypedDict]
    dollar_ref: NotRequired[Any]
    nft_metadata: NotRequired[IpfsFileInfoTypedDict]
    updated_at: NotRequired[float]
    r"""Timestamp (in milliseconds) at which IPFS export task was
    updated

    """


class AssetIpfs(BaseModel):
    spec: Optional[AssetSpec] = None

    dollar_ref: Annotated[Optional[Any], pydantic.Field(alias="$ref")] = None

    nft_metadata: Annotated[
        Optional[IpfsFileInfo], pydantic.Field(alias="nftMetadata")
    ] = None

    updated_at: Annotated[Optional[float], pydantic.Field(alias="updatedAt")] = None
    r"""Timestamp (in milliseconds) at which IPFS export task was
    updated

    """


class AssetStorageTypedDict(TypedDict):
    ipfs: NotRequired[AssetIpfsTypedDict]
    status: NotRequired[StorageStatusTypedDict]


class AssetStorage(BaseModel):
    ipfs: Optional[AssetIpfs] = None

    status: Optional[StorageStatus] = None


class AssetPhase(str, Enum):
    r"""Phase of the asset"""

    UPLOADING = "uploading"
    WAITING = "waiting"
    PROCESSING = "processing"
    READY = "ready"
    FAILED = "failed"
    DELETING = "deleting"
    DELETED = "deleted"


class AssetStatusTypedDict(TypedDict):
    r"""Status of the asset"""

    phase: AssetPhase
    r"""Phase of the asset"""
    updated_at: float
    r"""Timestamp (in milliseconds) at which the asset was last updated"""
    progress: NotRequired[float]
    r"""Current progress of the task creating this asset."""
    error_message: NotRequired[str]
    r"""Error message if the asset creation failed."""


class AssetStatus(BaseModel):
    r"""Status of the asset"""

    phase: AssetPhase
    r"""Phase of the asset"""

    updated_at: Annotated[float, pydantic.Field(alias="updatedAt")]
    r"""Timestamp (in milliseconds) at which the asset was last updated"""

    progress: Optional[float] = None
    r"""Current progress of the task creating this asset."""

    error_message: Annotated[Optional[str], pydantic.Field(alias="errorMessage")] = None
    r"""Error message if the asset creation failed."""


class HashTypedDict(TypedDict):
    hash: NotRequired[str]
    r"""Hash of the asset"""
    algorithm: NotRequired[str]
    r"""Hash algorithm used to compute the hash"""


class Hash(BaseModel):
    hash: Optional[str] = None
    r"""Hash of the asset"""

    algorithm: Optional[str] = None
    r"""Hash algorithm used to compute the hash"""


class AssetVideoSpecType(str, Enum):
    r"""type of track"""

    VIDEO = "video"
    AUDIO = "audio"


class TracksTypedDict(TypedDict):
    type: AssetVideoSpecType
    r"""type of track"""
    codec: str
    r"""Codec of the track"""
    start_time: NotRequired[float]
    r"""Start time of the track in seconds"""
    duration: NotRequired[float]
    r"""Duration of the track in seconds"""
    bitrate: NotRequired[float]
    r"""Bitrate of the track in bits per second"""
    width: NotRequired[float]
    r"""Width of the track - only for video tracks"""
    height: NotRequired[float]
    r"""Height of the track - only for video tracks"""
    pixel_format: NotRequired[str]
    r"""Pixel format of the track - only for video tracks"""
    fps: NotRequired[float]
    r"""Frame rate of the track - only for video tracks"""
    channels: NotRequired[float]
    r"""Amount of audio channels in the track"""
    sample_rate: NotRequired[float]
    r"""Sample rate of the track in samples per second - only for
    audio tracks

    """
    bit_depth: NotRequired[float]
    r"""Bit depth of the track - only for audio tracks"""


class Tracks(BaseModel):
    type: AssetVideoSpecType
    r"""type of track"""

    codec: str
    r"""Codec of the track"""

    start_time: Annotated[Optional[float], pydantic.Field(alias="startTime")] = None
    r"""Start time of the track in seconds"""

    duration: Optional[float] = None
    r"""Duration of the track in seconds"""

    bitrate: Optional[float] = None
    r"""Bitrate of the track in bits per second"""

    width: Optional[float] = None
    r"""Width of the track - only for video tracks"""

    height: Optional[float] = None
    r"""Height of the track - only for video tracks"""

    pixel_format: Annotated[Optional[str], pydantic.Field(alias="pixelFormat")] = None
    r"""Pixel format of the track - only for video tracks"""

    fps: Optional[float] = None
    r"""Frame rate of the track - only for video tracks"""

    channels: Optional[float] = None
    r"""Amount of audio channels in the track"""

    sample_rate: Annotated[Optional[float], pydantic.Field(alias="sampleRate")] = None
    r"""Sample rate of the track in samples per second - only for
    audio tracks

    """

    bit_depth: Annotated[Optional[float], pydantic.Field(alias="bitDepth")] = None
    r"""Bit depth of the track - only for audio tracks"""


class VideoSpecTypedDict(TypedDict):
    r"""Video metadata"""

    format: NotRequired[str]
    r"""Format of the asset"""
    duration: NotRequired[float]
    r"""Duration of the asset in seconds (float)"""
    bitrate: NotRequired[float]
    r"""Bitrate of the video in bits per second"""
    tracks: NotRequired[List[TracksTypedDict]]
    r"""List of tracks associated with the asset when the format
    contemplates them (e.g. mp4)

    """


class VideoSpec(BaseModel):
    r"""Video metadata"""

    format: Optional[str] = None
    r"""Format of the asset"""

    duration: Optional[float] = None
    r"""Duration of the asset in seconds (float)"""

    bitrate: Optional[float] = None
    r"""Bitrate of the video in bits per second"""

    tracks: Optional[List[Tracks]] = None
    r"""List of tracks associated with the asset when the format
    contemplates them (e.g. mp4)

    """


class AssetTypedDict(TypedDict):
    id: str
    source: SourceTypedDict
    name: str
    r"""The name of the asset. This is not necessarily the filename - it can be a custom name or title.

    """
    type: NotRequired[AssetType]
    r"""Type of the asset."""
    playback_id: NotRequired[str]
    r"""The playback ID to use with the Playback Info endpoint to retrieve playback URLs."""
    user_id: NotRequired[str]
    playback_url: NotRequired[str]
    r"""URL for HLS playback. **It is recommended to not use this URL**, and instead use playback IDs with the Playback Info endpoint to retrieve the playback URLs - this URL format is subject to change (e.g. https://livepeercdn.com/asset/ea03f37e-f861-4cdd-b495-0e60b6d753ad/index.m3u8)."""
    download_url: NotRequired[str]
    r"""The URL to directly download the asset, e.g. `https://livepeercdn.com/asset/eawrrk06ts2d0mzb/video`. It is not recommended to use this for playback."""
    playback_policy: NotRequired[Nullable[PlaybackPolicyTypedDict]]
    r"""Whether the playback policy for an asset or stream is public or signed"""
    creator_id: NotRequired[CreatorIDTypedDict]
    profiles: NotRequired[List[TranscodeProfileTypedDict]]
    r"""Requested profiles for the asset to be transcoded into. Configured
    on the upload APIs payload or through the `stream.recordingSpec`
    field for recordings. If not specified, default profiles are derived
    based on the source input. If this is a recording, the source will
    not be present in this list but will be available for playback.

    """
    storage: NotRequired[AssetStorageTypedDict]
    status: NotRequired[AssetStatusTypedDict]
    r"""Status of the asset"""
    project_id: NotRequired[str]
    r"""The ID of the project"""
    created_at: NotRequired[float]
    r"""Timestamp (in milliseconds) at which asset was created"""
    created_by_token_name: NotRequired[str]
    r"""Name of the token used to create this object"""
    size: NotRequired[float]
    r"""Size of the asset in bytes"""
    hash: NotRequired[Nullable[List[HashTypedDict]]]
    r"""Hash of the asset"""
    video_spec: NotRequired[VideoSpecTypedDict]
    r"""Video metadata"""


class Asset(BaseModel):
    id: str

    source: Source

    name: str
    r"""The name of the asset. This is not necessarily the filename - it can be a custom name or title.

    """

    type: Optional[AssetType] = None
    r"""Type of the asset."""

    playback_id: Annotated[Optional[str], pydantic.Field(alias="playbackId")] = None
    r"""The playback ID to use with the Playback Info endpoint to retrieve playback URLs."""

    user_id: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible.",
            alias="userId",
        ),
    ] = None

    playback_url: Annotated[Optional[str], pydantic.Field(alias="playbackUrl")] = None
    r"""URL for HLS playback. **It is recommended to not use this URL**, and instead use playback IDs with the Playback Info endpoint to retrieve the playback URLs - this URL format is subject to change (e.g. https://livepeercdn.com/asset/ea03f37e-f861-4cdd-b495-0e60b6d753ad/index.m3u8)."""

    download_url: Annotated[Optional[str], pydantic.Field(alias="downloadUrl")] = None
    r"""The URL to directly download the asset, e.g. `https://livepeercdn.com/asset/eawrrk06ts2d0mzb/video`. It is not recommended to use this for playback."""

    playback_policy: Annotated[
        OptionalNullable[PlaybackPolicy], pydantic.Field(alias="playbackPolicy")
    ] = UNSET
    r"""Whether the playback policy for an asset or stream is public or signed"""

    creator_id: Annotated[Optional[CreatorID], pydantic.Field(alias="creatorId")] = None

    profiles: Optional[List[TranscodeProfile]] = None
    r"""Requested profiles for the asset to be transcoded into. Configured
    on the upload APIs payload or through the `stream.recordingSpec`
    field for recordings. If not specified, default profiles are derived
    based on the source input. If this is a recording, the source will
    not be present in this list but will be available for playback.

    """

    storage: Optional[AssetStorage] = None

    status: Optional[AssetStatus] = None
    r"""Status of the asset"""

    project_id: Annotated[Optional[str], pydantic.Field(alias="projectId")] = None
    r"""The ID of the project"""

    created_at: Annotated[Optional[float], pydantic.Field(alias="createdAt")] = None
    r"""Timestamp (in milliseconds) at which asset was created"""

    created_by_token_name: Annotated[
        Optional[str], pydantic.Field(alias="createdByTokenName")
    ] = None
    r"""Name of the token used to create this object"""

    size: Optional[float] = None
    r"""Size of the asset in bytes"""

    hash: OptionalNullable[List[Hash]] = UNSET
    r"""Hash of the asset"""

    video_spec: Annotated[Optional[VideoSpec], pydantic.Field(alias="videoSpec")] = None
    r"""Video metadata"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "type",
            "playbackId",
            "userId",
            "playbackUrl",
            "downloadUrl",
            "playbackPolicy",
            "creatorId",
            "profiles",
            "storage",
            "status",
            "projectId",
            "createdAt",
            "createdByTokenName",
            "size",
            "hash",
            "videoSpec",
        ]
        nullable_fields = ["playbackPolicy", "hash"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
