"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .attestation import Attestation, AttestationTypedDict
from .playback_policy import PlaybackPolicy, PlaybackPolicyTypedDict
from enum import Enum
from livepeer.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional, TypedDict
from typing_extensions import Annotated, NotRequired


class PlaybackInfoType(str, Enum):
    LIVE = "live"
    VOD = "vod"
    RECORDING = "recording"


class Live(int, Enum):
    ZERO = 0
    ONE = 1


class Hrn(str, Enum):
    r"""Human Readable Name"""

    HLS_TS_ = "HLS (TS)"
    MP4 = "MP4"
    WEB_RTC_H264_ = "WebRTC (H264)"
    FLV_H264_ = "FLV (H264)"
    THUMBNAIL_JPEG_ = "Thumbnail (JPEG)"
    THUMBNAIL_PNG_ = "Thumbnail (PNG)"
    THUMBNAILS = "Thumbnails"


class PlaybackInfoMetaType(str, Enum):
    HTML5_APPLICATION_VND_APPLE_MPEGURL = "html5/application/vnd.apple.mpegurl"
    HTML5_VIDEO_MP4 = "html5/video/mp4"
    HTML5_VIDEO_H264 = "html5/video/h264"
    VIDEO_X_FLV = "video/x-flv"
    IMAGE_JPEG = "image/jpeg"
    IMAGE_PNG = "image/png"
    TEXT_VTT = "text/vtt"


class PlaybackInfoSourceTypedDict(TypedDict):
    hrn: Hrn
    r"""Human Readable Name"""
    type: PlaybackInfoMetaType
    url: str
    size: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]
    bitrate: NotRequired[float]


class PlaybackInfoSource(BaseModel):
    hrn: Hrn
    r"""Human Readable Name"""

    type: PlaybackInfoMetaType

    url: str

    size: Optional[float] = None

    width: Optional[float] = None

    height: Optional[float] = None

    bitrate: Optional[float] = None


class PlaybackInfoHrn(str, Enum):
    HLS_TS_ = "HLS (TS)"


class PlaybackInfoMetaDvrPlaybackType(str, Enum):
    HTML5_APPLICATION_VND_APPLE_MPEGURL = "html5/application/vnd.apple.mpegurl"


class DvrPlaybackTypedDict(TypedDict):
    hrn: NotRequired[PlaybackInfoHrn]
    type: NotRequired[PlaybackInfoMetaDvrPlaybackType]
    url: NotRequired[str]
    error: NotRequired[str]


class DvrPlayback(BaseModel):
    hrn: Optional[PlaybackInfoHrn] = None

    type: Optional[PlaybackInfoMetaDvrPlaybackType] = None

    url: Optional[str] = None

    error: Optional[str] = None


class MetaTypedDict(TypedDict):
    source: List[PlaybackInfoSourceTypedDict]
    live: NotRequired[Live]
    playback_policy: NotRequired[Nullable[PlaybackPolicyTypedDict]]
    r"""Whether the playback policy for an asset or stream is public or signed"""
    dvr_playback: NotRequired[List[DvrPlaybackTypedDict]]
    attestation: NotRequired[AttestationTypedDict]


class Meta(BaseModel):
    source: List[PlaybackInfoSource]

    live: Optional[Live] = None

    playback_policy: Annotated[
        OptionalNullable[PlaybackPolicy], pydantic.Field(alias="playbackPolicy")
    ] = UNSET
    r"""Whether the playback policy for an asset or stream is public or signed"""

    dvr_playback: Annotated[
        Optional[List[DvrPlayback]], pydantic.Field(alias="dvrPlayback")
    ] = None

    attestation: Optional[Attestation] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["live", "playbackPolicy", "dvrPlayback", "attestation"]
        nullable_fields = ["playbackPolicy"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PlaybackInfoTypedDict(TypedDict):
    type: PlaybackInfoType
    meta: MetaTypedDict


class PlaybackInfo(BaseModel):
    type: PlaybackInfoType

    meta: Meta
