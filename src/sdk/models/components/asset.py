"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from .creator_id import CreatorID
from .encryption import Encryption
from .encryption_output import EncryptionOutput
from .ipfs_file_info import IpfsFileInfo
from .ipfs_file_info_input import IpfsFileInfoInput
from .playback_policy import PlaybackPolicy
from .storage_status import StorageStatus
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import List, Optional, Union

class AssetType(str, Enum):
    r"""Type of the asset."""
    VIDEO = 'video'
    AUDIO = 'audio'

class AssetSchemasSource3Type(str, Enum):
    DIRECT_UPLOAD = 'directUpload'
    CLIP = 'clip'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Asset3:
    type: AssetSchemasSource3Type = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    encryption: Optional[EncryptionOutput] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryption'), 'exclude': lambda f: f is None }})
    


class AssetSchemasSourceType(str, Enum):
    RECORDING = 'recording'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Two:
    session_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sessionId') }})
    r"""ID of the session from which this asset was created"""
    type: AssetSchemasSourceType = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    


class AssetSchemasType(str, Enum):
    URL = 'url'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Asset1Output:
    type: AssetSchemasType = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    url: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url') }})
    r"""URL from which the asset was uploaded"""
    encryption: Optional[EncryptionOutput] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryption'), 'exclude': lambda f: f is None }})
    gateway_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gatewayUrl'), 'exclude': lambda f: f is None }})
    r"""Gateway URL from asset if parsed from provided URL on upload."""
    


class AssetNftMetadataTemplate(str, Enum):
    r"""Name of the NFT metadata template to export. 'player'
    will embed the Livepeer Player on the NFT while 'file'
    will reference only the immutable MP4 files.
    """
    FILE = 'file'
    PLAYER = 'player'


@dataclasses.dataclass
class AssetNftMetadata:
    r"""Additional data to add to the NFT metadata exported to
    IPFS. Will be deep merged with the default metadata
    exported.
    """
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AssetSpec:
    nft_metadata: Optional[AssetNftMetadata] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nftMetadata'), 'exclude': lambda f: f is None }})
    r"""Additional data to add to the NFT metadata exported to
    IPFS. Will be deep merged with the default metadata
    exported.
    """
    nft_metadata_template: Optional[AssetNftMetadataTemplate] = dataclasses.field(default=AssetNftMetadataTemplate.FILE, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nftMetadataTemplate'), 'exclude': lambda f: f is None }})
    r"""Name of the NFT metadata template to export. 'player'
    will embed the Livepeer Player on the NFT while 'file'
    will reference only the immutable MP4 files.
    """
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AssetIpfs:
    cid: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cid'), 'exclude': lambda f: f is None }})
    r"""CID of the file on IPFS"""
    gateway_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gatewayUrl'), 'exclude': lambda f: f is None }})
    r"""URL to access file via HTTP through an IPFS gateway"""
    nft_metadata: Optional[IpfsFileInfo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nftMetadata'), 'exclude': lambda f: f is None }})
    spec: Optional[AssetSpec] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('spec'), 'exclude': lambda f: f is None }})
    updated_at: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updatedAt'), 'exclude': lambda f: f is None }})
    r"""Timestamp (in milliseconds) at which IPFS export task was
    updated
    """
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""URL with IPFS scheme for the file"""
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AssetStorage:
    ipfs: Optional[AssetIpfs] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipfs'), 'exclude': lambda f: f is None }})
    status: Optional[StorageStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    


class AssetPhase(str, Enum):
    r"""Phase of the asset"""
    UPLOADING = 'uploading'
    WAITING = 'waiting'
    PROCESSING = 'processing'
    READY = 'ready'
    FAILED = 'failed'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AssetStatus:
    r"""Status of the asset"""
    phase: AssetPhase = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('phase') }})
    r"""Phase of the asset"""
    updated_at: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updatedAt') }})
    r"""Timestamp (in milliseconds) at which the asset was last updated"""
    error_message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('errorMessage'), 'exclude': lambda f: f is None }})
    r"""Error message if the asset creation failed."""
    progress: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('progress'), 'exclude': lambda f: f is None }})
    r"""Current progress of the task creating this asset."""
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Hash:
    algorithm: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('algorithm'), 'exclude': lambda f: f is None }})
    r"""Hash algorithm used to compute the hash"""
    hash: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hash'), 'exclude': lambda f: f is None }})
    r"""Hash of the asset"""
    


class AssetSchemasVideoSpecType(str, Enum):
    r"""type of track"""
    VIDEO = 'video'
    AUDIO = 'audio'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Tracks:
    codec: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('codec') }})
    r"""Codec of the track"""
    type: AssetSchemasVideoSpecType = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""type of track"""
    bit_depth: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bitDepth'), 'exclude': lambda f: f is None }})
    r"""Bit depth of the track - only for audio tracks"""
    bitrate: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bitrate'), 'exclude': lambda f: f is None }})
    r"""Bitrate of the track in bits per second"""
    channels: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('channels'), 'exclude': lambda f: f is None }})
    r"""Amount of audio channels in the track"""
    duration: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('duration'), 'exclude': lambda f: f is None }})
    r"""Duration of the track in seconds"""
    fps: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fps'), 'exclude': lambda f: f is None }})
    r"""Frame rate of the track - only for video tracks"""
    height: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('height'), 'exclude': lambda f: f is None }})
    r"""Height of the track - only for video tracks"""
    pixel_format: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pixelFormat'), 'exclude': lambda f: f is None }})
    r"""Pixel format of the track - only for video tracks"""
    sample_rate: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sampleRate'), 'exclude': lambda f: f is None }})
    r"""Sample rate of the track in samples per second - only for
    audio tracks
    """
    start_time: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('startTime'), 'exclude': lambda f: f is None }})
    r"""Start time of the track in seconds"""
    width: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('width'), 'exclude': lambda f: f is None }})
    r"""Width of the track - only for video tracks"""
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class VideoSpec:
    r"""Video metadata"""
    bitrate: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bitrate'), 'exclude': lambda f: f is None }})
    r"""Bitrate of the video in bits per second"""
    duration: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('duration'), 'exclude': lambda f: f is None }})
    r"""Duration of the asset in seconds (float)"""
    format: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('format'), 'exclude': lambda f: f is None }})
    r"""Format of the asset"""
    tracks: Optional[List[Tracks]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tracks'), 'exclude': lambda f: f is None }})
    r"""List of tracks associated with the asset when the format
    contemplates them (e.g. mp4)
    """
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Asset:
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the asset. This is not necessarily the filename, can be a
    custom name or title
    """
    source: Union[Asset1Output, Two, Asset3] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source') }})
    created_at: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdAt'), 'exclude': lambda f: f is None }})
    r"""Timestamp (in milliseconds) at which asset was created"""
    creator_id: Optional[Union[CreatorID1]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('creatorId'), 'exclude': lambda f: f is None }})
    download_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('downloadUrl'), 'exclude': lambda f: f is None }})
    r"""URL to manually download the asset if desired"""
    hash: Optional[List[Hash]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hash'), 'exclude': lambda f: f is None }})
    r"""Hash of the asset"""
    playback_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('playbackId'), 'exclude': lambda f: f is None }})
    r"""Used to form playback URL and storage folder"""
    playback_policy: Optional[PlaybackPolicy] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('playbackPolicy'), 'exclude': lambda f: f is None }})
    r"""Whether the playback policy for a asset or stream is public or signed"""
    playback_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('playbackUrl'), 'exclude': lambda f: f is None }})
    r"""URL for HLS playback"""
    size: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('size'), 'exclude': lambda f: f is None }})
    r"""Size of the asset in bytes"""
    status: Optional[AssetStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""Status of the asset"""
    storage: Optional[AssetStorage] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('storage'), 'exclude': lambda f: f is None }})
    type: Optional[AssetType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Type of the asset."""
    video_spec: Optional[VideoSpec] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('videoSpec'), 'exclude': lambda f: f is None }})
    r"""Video metadata"""
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Three:
    type: AssetSchemasSource3Type = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    encryption: Optional[Encryption] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryption'), 'exclude': lambda f: f is None }})
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Asset1:
    type: AssetSchemasType = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    url: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url') }})
    r"""URL from which the asset was uploaded"""
    encryption: Optional[Encryption] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryption'), 'exclude': lambda f: f is None }})
    gateway_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gatewayUrl'), 'exclude': lambda f: f is None }})
    r"""Gateway URL from asset if parsed from provided URL on upload."""
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AssetIpfsInput:
    cid: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cid'), 'exclude': lambda f: f is None }})
    r"""CID of the file on IPFS"""
    nft_metadata: Optional[IpfsFileInfoInput] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nftMetadata'), 'exclude': lambda f: f is None }})
    spec: Optional[AssetSpec] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('spec'), 'exclude': lambda f: f is None }})
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AssetStorageInput:
    ipfs: Optional[AssetIpfsInput] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipfs'), 'exclude': lambda f: f is None }})
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AssetInput:
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the asset. This is not necessarily the filename, can be a
    custom name or title
    """
    source: Union[Asset1, Two, Three] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('source') }})
    creator_id: Optional[Union[CreatorID1]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('creatorId'), 'exclude': lambda f: f is None }})
    hash: Optional[List[Hash]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hash'), 'exclude': lambda f: f is None }})
    r"""Hash of the asset"""
    playback_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('playbackId'), 'exclude': lambda f: f is None }})
    r"""Used to form playback URL and storage folder"""
    playback_policy: Optional[PlaybackPolicy] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('playbackPolicy'), 'exclude': lambda f: f is None }})
    r"""Whether the playback policy for a asset or stream is public or signed"""
    static_mp4: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('staticMp4'), 'exclude': lambda f: f is None }})
    r"""Whether to generate MP4s for the asset."""
    storage: Optional[AssetStorageInput] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('storage'), 'exclude': lambda f: f is None }})
    type: Optional[AssetType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Type of the asset."""
    

